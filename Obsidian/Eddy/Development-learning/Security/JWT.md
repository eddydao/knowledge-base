- JWT is a open standard use for authenticating data owners and transmitting data between parties` using JSON format
- JWT send in HTTP request with a digital signature, it can be signed using a secret (HMAC algorithm) or public/private key pair ( using RSA or ECDSA) 
- JWT is stateless

# Structure
- A JWT contains 3 part:
	- Header: contains algorithm that being use, and type of the token ( mostly ‘JWT’)
	- Payload: contains information of what ever need to be authenticating (common: sub (user identifier), role( user role), exp(expiration time))
	- Signature: a String that generated by a cryptographic algorithm to verify the integrity of the token

# How JWT works
1. User log in
- Client sends username and password to the authentication server
2. Server validates credentials
- If the credentials are correct, the server generates a JWT
- the JWT is sent back to the client in the response
3. Client stores JWT
- Client can store the JWT in:
	- Local storage 
	- Session storage
	- Http-only cookies ( recommended for security)
4. Client sends JWT in API requests
- Include the JWT in the Authorization header
5. Server verifies JWT
- Extract the JWT from the request
- Validate the signature using the secret key
- Processes the request if valid

# JWT flow in a REST API
```
(Client) → [POST] Login (username, password) → (Server)
(Server) → Validate User → Generate JWT → (Client)
(Client) → Store JWT → Send Requests with JWT → (Server)
(Server) → Validate JWT → Authorize Request → Respond
```

# Advantages of JWT
- **Stateless**: no need to store session data in server
- **Compact**: small in size and easily transmittable
- **Secure**: Cryptographically signed to prevent tampering
- **Scalable**: ideal for micro-services and distributed systems

# Best practices
- **Use Http-only cookies**: prevents [[XSS attacks]]
- **Set expire time**: reduces risk of token misuse
- **Strong secret key**
- **Token revocation**: using refresh token or blacklisting
- **Use HTTPS**: prevent token interception
# Implementing in Spring Boot
1. Add dependencies
```
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

2. Create JWT util class
```java
@Component
public class JwtUtil {
    private final String SECRET_KEY = "MySuperSecretKeyForJWTGeneration";  // should be externalize the secret key in env file
    private final long EXPIRATION_TIME = 1000 * 60 * 60; // 1 Hour

    private Key getSigningKey() {
        return Keys.hmacShaKeyFor(SECRET_KEY.getBytes());
    }

    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public String extractUsername(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }

    public boolean validateToken(String token, String username) {
        return (username.equals(extractUsername(token)) && !isTokenExpired(token));
    }

    private boolean isTokenExpired(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getExpiration()
                .before(new Date());
    }
}
```

3. Add JWT authentication filter
```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtil jwtUtil, UserDetailsService userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                    FilterChain filterChain) throws ServletException, IOException {
        String authorizationHeader = request.getHeader("Authorization");

        if (authorizationHeader == null || !authorizationHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String token = authorizationHeader.substring(7);
        String username = jwtUtil.extractUsername(token);

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            if (jwtUtil.validateToken(token, userDetails.getUsername())) {
                UsernamePasswordAuthenticationToken authenticationToken =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                SecurityContextHolder.getContext().setAuthentication(authenticationToken);
            }
        }
        filterChain.doFilter(request, response);
    }
}
```